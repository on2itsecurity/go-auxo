package zerotrust

import (
	"encoding/json"
	"fmt"

	"github.com/on2itsecurity/go-auxo/utils"
)

// Location represents a location object
type Location struct {
	ID            string `json:"id,omitempty"`             //ID will be generated by the back-end, cannot be set manually
	UniquenessKey string `json:"uniqueness_key,omitempty"` //Key to prevent duplicates, especially in parallel processing, can be set manually
	Name          string `json:"name"`                     //Name of the location
	Coords        Coords `json:"coords,omitempty"`         //Coordinates
}

// Coords represents a coords object as used in Location
type Coords struct {
	Latitude  float64 `json:"lat"`  //Latitude of the location
	Longitude float64 `json:"long"` //Longitude of the location
}

// --- Functions ---

// CreateLocation will create a location object and passes it to the API.
// It returns a Location object.
func (zt *ZeroTrust) CreateLocation(name string, latitude float64, longitude float64, replace bool) (*Location, error) {
	location := Location{
		Name: name,
		Coords: Coords{
			Latitude:  latitude,
			Longitude: longitude,
		},
	}

	result, err := zt.CreateLocationByObject(location, replace)

	if err != nil {
		return result, err
	}

	return result, nil
}

// CreateLocationByObject creates a location by passing a Location object
// It returns a Location object.
func (zt *ZeroTrust) CreateLocationByObject(location Location, replace bool) (*Location, error) {
	call := "create-location"
	if replace {
		call = "create-or-replace-location"
	}

	method := "POST"

	data, err := json.Marshal(utils.WrapItems(location))
	if err != nil {
		return nil, err
	}

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, string(data))

	if err != nil {
		return nil, err
	}

	newLocation, err := utils.UnwrapItems[Location](result)

	if err != nil {
		return nil, err
	}

	return newLocation[0], nil
}

// DeleteLocationsAll will delete ALL locations
func (zt *ZeroTrust) DeleteLocations() error {
	locations, err := zt.GetLocations()

	if err != nil {
		return err
	}

	for _, loc := range locations {
		err := zt.DeleteLocationByID(loc.ID)
		if err != nil {
			return err
		}
	}

	return nil
}

// DeleteLocationByID will delete the location
func (zt *ZeroTrust) DeleteLocationByID(id string) error {
	call := "remove-location?id=" + id
	method := "POST"

	_, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return err
	}

	return nil
}

// GetLocationByID will get a location by ID
// It returns a Location object.
func (zt *ZeroTrust) GetLocationByID(locationID string) (*Location, error) {
	call := "get-location?id=" + locationID
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	locations, err := utils.UnwrapItems[Location](result)

	if err != nil {
		return nil, err
	}

	if !(len(locations) > 0) {
		return nil, fmt.Errorf("No location found with id: %s", locationID)
	}

	return locations[0], nil
}

// GetLocationsByRelationID will get all locations of the relation (based on used API Token)
// It returns an array with all the Location objects.
func (zt *ZeroTrust) GetLocations() ([]*Location, error) {
	call := "get-locations"
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	locations, err := utils.UnwrapItems[Location](result)

	if err != nil {
		return nil, err
	}

	return locations, nil
}

// UpdateLocation will update/replace existing location, but keeps the ID.
// Returns the updated location
func (zt *ZeroTrust) UpdateLocation(location Location) (*Location, error) {
	result, err := zt.CreateLocationByObject(location, true)

	if err != nil {
		return nil, err
	}

	return result, nil
}
