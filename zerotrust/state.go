package zerotrust

import (
	"encoding/json"
	"fmt"

	"github.com/on2itsecurity/go-auxo/utils"
)

// State represents the State object
type State struct {
	ID               string    `json:"id,omitempty"`                  //ID will be generated by the back-end, cannot be set manually
	UniquenessKey    string    `json:"uniqueness_key,omitempty"`      //Key to prevent duplicates, especially in parallel processing, can be set manually
	Description      string    `json:"description,omitempty"`         //Good practice to set a description, since multiple states of the same type can be attached to a Protect Surface
	ProtectSurface   string    `json:"protectsurface_id"`             //Attached protect surface ID (mandatory)
	ContentType      string    `json:"content_type" defailt:"ipv4"`   //Contect Type: `ipv4`, `ipv6`, `azure_cloud`, `aws_cloud`, `gcp_cloud`, `container`, `hostname`, `user_identity`
	Location         string    `json:"location_id"`                   //Attaced location ID (mandatory)
	ExistsOnAssetIDs []string  `json:"exists_on_asset_ids,omitempty"` //IDs of the managed assets providing this information
	Maintainer       string    `json:"maintainer,omitempty"`          //Either: `portal_manual` or `api``
	Content          *[]string `json:"content,omitempty"`             //The actual content f.e. `["10.10.10.1", "10.10.10.2"]`
}

//--- Functions ---

// CreateStateByObject creates a state by passing a State object
// Requires a valid State object.
// Returns the created State object or an error.
func (zt *ZeroTrust) CreateStateByObject(state State) (*State, error) {
	call := "create-or-replace-state"
	method := "POST"

	if state.ContentType == "" {
		state.ContentType = "ipv4"
	}

	data, err := json.Marshal(utils.WrapItems(state))
	if err != nil {
		return nil, err
	}

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, string(data))

	if err != nil {
		return nil, err
	}

	newState, err := utils.UnwrapItems[State](result)

	if err != nil {
		return nil, err
	}

	return newState[0], nil
}

// DeleteStates will delete ALL states belonging to a ProtectSurface
// Requires a valid ProtectSurface ID.
func (zt *ZeroTrust) DeleteStates(psID string) error {
	states, err := zt.GetStatesByProtectSurfaceID(psID)

	if err != nil {
		return err
	}

	for _, s := range states {
		err := zt.DeleteStateByID(s.ID)
		if err != nil {
			return err
		}
	}

	return nil
}

// DeleteStateByID will delete the State
func (zt *ZeroTrust) DeleteStateByID(id string) error {
	call := "remove-state?id=" + id
	method := "POST"

	_, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return err
	}

	return nil
}

// GetState By ID will get a state by ID
func (zt *ZeroTrust) GetStateByID(id string) (*State, error) {
	call := "get-state" + "?id=" + id
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	states, err := utils.UnwrapItems[State](result)

	if err != nil {
		return nil, err
	}

	if !(len(states) > 0) {
		return nil, fmt.Errorf("No state found with id %s", id)
	}

	return states[0], nil
}

// GetStatesAll will get all states of the relation (based upon used API Token)
// It returns an array with all the state objects.
func (zt *ZeroTrust) GetStates() ([]*State, error) {
	call := "get-states"
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err

	}

	states, err := utils.UnwrapItems[State](result)

	if err != nil {
		return nil, err
	}

	return states, nil
}

// GetStatesByProtectSurfaceID will get all states of the given Protect Surface ID.
// It returns an array with all the state objects.
func (zt *ZeroTrust) GetStatesByProtectSurfaceID(psID string) ([]*State, error) {
	call := "get-states-by-protectsurface" + "?id=" + psID
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	states, err := utils.UnwrapItems[State](result)

	if err != nil {
		return nil, err
	}

	return states, nil
}

// UpdateState will update/replace existing state, but keeps the ID.
// Returns the updated state
func (zt *ZeroTrust) UpdateState(state State) (*State, error) {
	result, err := zt.CreateStateByObject(state)

	if err != nil {
		return nil, err
	}

	return result, nil

}
