package zerotrust

import (
	"encoding/json"
	"fmt"

	"github.com/on2itsecurity/go-auxo/utils"
)

// ProtectSurface holds all the fields for the ProtectSurface "object"
type ProtectSurface struct {
	ID                      string                  `json:"id,omitempty"`                         //ID will be generated by the back-end, cannot be set manually
	UniquenessKey           string                  `json:"uniqueness_key,omitempty"`             //Key to prevent duplicates, especially in parallel processing, can be set manually
	Name                    string                  `json:"name"`                                 //Name of the protect surface
	Description             string                  `json:"description"`                          //Description of the protect surface
	MainContactPersonID     string                  `json:"main_contact_person_id,omitempty"`     //Contact Person ID, must be a valid ID within the relation (leave empty if unknown)
	SecurityContactPersonID string                  `json:"security_contact_person_id,omitempty"` //Security Person ID, must be a valid ID within the relation (leave empty if unknown)
	InControlBoundary       bool                    `json:"in_control_boundary"`                  //Is this protect surface in the control boundary (are you responsonble for its security)
	InZeroTrustFocus        bool                    `json:"in_zero_trust_focus"`                  //Is this protect surface in focus, should the security be measured and reported
	Relevance               int                     `json:"relevance"`                            //How important (0=not-100=very) is this protect service
	Confidentiality         int                     `json:"confidentiality,omitempty"`            //Score normally between 1-5
	Integrity               int                     `json:"integrity,omitempty"`                  //Score normally between 1-5
	Availability            int                     `json:"availability,omitempty"`               //Score normally between 1-5
	DataTags                []string                `json:"data_tags"`                            //What data holds this protect suface, f.e. PII, PCI
	ComplianceTags          []string                `json:"compliance_tags"`                      //What compliance frameworks should be respected, f.e. GDPR, PCI-DSS, SOX
	CustomerLabels          map[string]string       `json:"customer_labels"`                      //Customer specific Key=Value pairs for easy grouping and searching
	SocTags                 []string                `json:"soc_tags"`                             //Leave untouched, only being set by the SOC.
	FlowsFromOtherPS        map[string]Flow         `json:"flows_from_other_ps,omitempty"`        //Other PS-ID -> Flow
	FlowsToOtherPS          map[string]Flow         `json:"flows_to_other_ps,omitempty"`          //Other PS-ID -> Flow
	FlowsFromOutside        Flow                    `json:"flows_from_outside,omitempty"`         //Flow
	FlowsToOutside          Flow                    `json:"flows_to_outside,omitempty"`           //Flow
	Measures                map[string]MeasureState `json:"measures,omitempty"`                   //Measures (could vary per relation)
	Maturity                Maturity                `json:"maturity,omitempty"`                   //Maturity (per zero trust step)
}

// Flow contains the policy for the flow
type Flow struct {
	Allow bool `json:"allow"` //Is the flow allowed or not.
}

// MeasureState contains the measure assignment, implementation, Evideance and Acceptance
type MeasureState struct { //Pointers to prevent posting empty objects (which result in 500)
	Assignment     *Assignment     `json:"assignment,omitempty"`      //Assignment
	Implementation *Implementation `json:"implementation,omitempty"`  //Implementation
	Evidence       *Evidence       `json:"evidence,omitempty"`        //Evidence
	RiskAcceptance *RiskAcceptance `json:"risk_acceptance,omitempty"` //RiskAcceptance
}

// Assignment contains the assignment details
type Assignment struct {
	Assigned                 bool   `json:"assigned"`                               //Is the measure assigned (applicable for the protect surface)
	LastDeterminedByPersonID string `json:"last_determined_by_person_id,omitempty"` //E-mail of the person responsible for the assignment
	LastDeterminedTimestamp  int    `json:"last_determined_timestamp,omitempty"`    //Unix time of the assignment
}

// Implementation contains the implementation details
type Implementation struct {
	Implemented              bool   `json:"implemented"`                            //Is this measure implemented
	LastDeterminedByPersonID string `json:"last_determined_by_person_id,omitempty"` //E-mail of the person who validated the implementation
	LastDeterminedTimestamp  int    `json:"last_determined_timestamp,omitempty"`    //Unix time of the validation
}

// Evidence contains the evidence details
type Evidence struct {
	Evidenced                bool   `json:"evidenced"`                              //Is the implementation working as expected did we evidenced it
	LastDeterminedByPersonID string `json:"last_determined_by_person_id,omitempty"` //E-mail of the person who gathered the evidence
	LastDeterminedTimestamp  int    `json:"last_determined_timestamp,omitempty"`    //Unix time of the evidence
}

// RiskAcceptance contains the risk acceptance details
type RiskAcceptance struct {
	LastDeterminedByPersonID     string `json:"last_determined_by_person_id,omitempty"`    //E-mail of the person who accepted the risks
	LastDeterminedTimestamp      int    `json:"last_determined_timestamp,omitempty"`       //Unix time of the acceptance
	RiskNoImplementationAccepted bool   `json:"risk_no_implementation_accepted,omitempty"` //Is it accepted that there is no validation of the implementation
	RiskNoEvidenceAccepted       bool   `json:"risk_no_evidence_accepted"`                 //Is it accepted that there is no evidence of a working implementation
	RiskAcceptedComment          string `json:"risk_accepted_comment"`                     //Why is the risk accepted
}

// Maturity contains the maturity details
type Maturity struct {
	Step1 int `json:"step_1,omitempty"` //Maturity of Zero Trust step 1
	Step2 int `json:"step_2,omitempty"` //Maturity of Zero Trust step 2
	Step3 int `json:"step_3,omitempty"` //Maturity of Zero Trust step 3
	Step4 int `json:"step_4,omitempty"` //Maturity of Zero Trust step 4
	Step5 int `json:"step_5,omitempty"` //Maturity of Zero Trust step 5
}

// --- Functions ---

// CreateProtectSurface will create a protectsurface object and passes it to the API, with the minimal values.
// If replace is true, it will replace the existing protectsurface object if applicable.
// It returns a ProtectSurface object.
func (zt *ZeroTrust) CreateProtectSurface(name string, relevance int, replace bool) (*ProtectSurface, error) {

	protectsurface := ProtectSurface{
		Name:      name,
		Relevance: relevance,
	}

	ps, err := zt.CreateProtectSurfaceByObject(protectsurface, replace)

	if err != nil {
		return nil, err
	}

	return ps, nil
}

// CreateProtectSurfaceByObject creates a protectsurface by passing a protectsurface object
// If replace is true, it will replace the existing protectsurface object if applicable.
// It returns a protectsurface object.
func (zt *ZeroTrust) CreateProtectSurfaceByObject(protectsurface ProtectSurface, replace bool) (*ProtectSurface, error) {
	call := "create-protectsurface"

	if replace {
		call = "create-or-replace-protectsurface"
	}

	method := "POST"

	data, err := json.Marshal(utils.WrapItems(protectsurface))

	if err != nil {
		return nil, err
	}

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, string(data))

	if err != nil {
		return nil, err
	}

	newProtectSurface, err := utils.UnwrapItems[ProtectSurface](result)

	if err != nil {
		return nil, err
	}
	return newProtectSurface[0], nil
}

// DeleteProtectSurfaceByID will delete the protectsurface
func (zt *ZeroTrust) DeleteProtectSurfaceByID(id string) error {
	call := "remove-protectsurface-and-states?id=" + id
	method := "POST"

	_, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return err
	}

	return nil
}

// DeleteProtectSurfaces will delete ALL ProtectSurfaces
func (zt *ZeroTrust) DeleteProtectSurfaces() error {
	pss, err := zt.GetProtectSurfaces()

	if err != nil {
		return err
	}

	for _, ps := range pss {
		err := zt.DeleteProtectSurfaceByID(ps.ID)
		if err != nil {
			return err
		}
	}

	return nil
}

// GetProtectSurfaceByID will get a protectsurface by ID
// It returns a ProtectSurface object.
func (zt *ZeroTrust) GetProtectSurfaceByID(protectSurfaceID string) (*ProtectSurface, error) {
	call := "get-protectsurface?id=" + protectSurfaceID
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	protectsurfaces, err := utils.UnwrapItems[ProtectSurface](result)

	if err != nil {
		return nil, err
	}

	if !(len(protectsurfaces) > 0) {
		return nil, fmt.Errorf("No protectsurface found with ID: %s", protectSurfaceID)
	}

	return protectsurfaces[0], nil
}

// GetProtectSurfaceByStateTypeAndValue will get a protectsurface by state type and value (i.e. by IP address)
// Method could either be "ip" or "exact", when "ip" is used, the value will be matched to the most specific matching CIDR.
// It returns a (single) ProtectSurface object.
func (zt *ZeroTrust) GetProtectSurfaceByStateTypeAndValue(stateType, match_method, value string) (*ProtectSurface, error) {
	if !(match_method == "ip" || match_method == "exact") {
		return nil, fmt.Errorf("Invalid match method: %s (only 'ip' or 'exact' are supported)", match_method)
	}

	call := fmt.Sprintf("get-protectsurface-by-state-type-and-value-match?match_type=%s&match_method=%s&match_value=%s", stateType, match_method, value)
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	protectsurfaces, err := utils.UnwrapItems[ProtectSurface](result)

	if err != nil {
		return nil, err
	}

	if !(len(protectsurfaces) > 0) {
		return nil, fmt.Errorf("No matching protect surface found with state_type=%s, method=%s, value=%s", stateType, match_method, value)
	}

	return protectsurfaces[0], nil
}

// GetProtectSurfaces will get all protectsurfaces of the relations (based on used API token)
// It returns an array with all the ProtectSurface objects.
func (zt *ZeroTrust) GetProtectSurfaces() ([]*ProtectSurface, error) {
	call := "get-protectsurfaces"
	method := "GET"

	result, err := zt.apiClient.ApiCall(zt.apiEndpoint+call, method, "")

	if err != nil {
		return nil, err
	}

	protectsurfaces, err := utils.UnwrapItems[ProtectSurface](result)

	if err != nil {
		return nil, err
	}

	return protectsurfaces, nil
}

// UpdateProtectSurface will update/replace existing ProtectSurface, but keeps the ID.
// Returns the updated protectsurface
func (zt *ZeroTrust) UpdateProtectSurface(ps ProtectSurface) (*ProtectSurface, error) {
	result, err := zt.CreateProtectSurfaceByObject(ps, true)

	if err != nil {
		return nil, err
	}

	return result, nil
}
